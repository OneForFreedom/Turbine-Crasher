<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Turbine Crasher</title>
<style>
  /* Full viewport, flex center */
  html, body {
    margin: 0; height: 100%;
    background: linear-gradient(135deg, #001100, #004400, #006622);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    color: #a4fcae;
    user-select: none;
  }
  h1 {
    margin: 20px 0 5px;
    font-weight: 700;
    text-shadow: 0 0 8px #76ff72;
    font-size: 3rem;
    letter-spacing: 3px;
  }
  h2 {
    margin: 5px 0 15px;
    font-weight: 500;
    font-size: 1.1rem;
    color: #b0ffb0cc;
    text-shadow: 0 0 5px #2a662a;
  }
  canvas {
    flex-grow: 1;
    width: 100vw;
    max-width: 1200px;
    height: 60vh;
    border-radius: 12px;
    border: 2px solid #68d468;
    background: linear-gradient(180deg, #112211, #003300);
    box-shadow:
      0 0 12px #43a743,
      inset 0 0 15px #0f0f0f,
      inset 0 -5px 20px #0a0a0a;
    display: block;
    margin-bottom: 20px;
  }
  #winScreen {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(10, 40, 10, 0.95);
    padding: 30px 50px;
    border-radius: 15px;
    border: 3px solid #6ff06f;
    box-shadow: 0 0 30px #6ff06fcc;
    display: none;
    text-align: center;
    color: #b3ffb3;
    font-weight: 600;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    z-index: 10;
  }
  button {
    background: transparent;
    border: 2px solid #a4fcae;
    color: #a4fcae;
    padding: 12px 26px;
    font-size: 1.2rem;
    font-weight: 600;
    border-radius: 10px;
    cursor: pointer;
    margin: 0 12px 20px 12px;
    transition: all 0.25s ease;
    box-shadow: 0 0 6px #49a549;
  }
  button:hover {
    background: #a4fcae;
    color: #003300;
    box-shadow: 0 0 20px #27a527;
    transform: scale(1.1);
  }
  #bestScores {
    margin-top: 5px;
    font-size: 1rem;
    font-weight: 600;
    text-shadow: 0 0 4px #2a662a;
  }
</style>
</head>
<body>

<h1>Turbine Crasher</h1>
<h2>Activate all bars to overload the core.</h2>
<canvas id="gameCanvas"></canvas>

<div>
  <button onclick="startGame('easy')">Start Easy</button>
  <button onclick="startGame('hard')">Start Hard</button>
</div>

<div id="winScreen">
  <h2>You Win!</h2>
  <div id="stats"></div>
  <button onclick="resetGame()">Reset</button>
</div>

<div id="bestScores">No records yet.</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth * 0.9;
  canvas.height = window.innerHeight * 0.6;
}
window.addEventListener('resize', () => {
  resizeCanvas();
  if (gameRunning) draw(); // redraw on resize
});
resizeCanvas();

let numTurbines;
let bars = [];
let turbines = [];
let startTime, clickCount;
let gameRunning = false;

let BAR_WIDTH;
let BAR_MAX_HEIGHT;
let BAR_BASE_Y;
let PADDING;

function randPattern(n) {
  return Array.from({length: n}, () => Math.random() < 0.5);
}

function startGame(mode) {
  numTurbines = mode === 'hard' ? 10 : 6;
  bars = Array(numTurbines).fill(false).map(() => ({target: false, currentHeight: 10}));
  turbines = [];

  for (let i=0; i<numTurbines; i++) {
    turbines.push({pattern: randPattern(numTurbines), spinAngle: Math.random()*Math.PI*2, spinSpeed: 0.07 + Math.random()*0.06, clickBounce: 0});
  }

  clickCount = 0;
  startTime = performance.now();
  gameRunning = true;
  document.getElementById('winScreen').style.display = 'none';

  // Dynamically calculate sizes based on canvas
  BAR_WIDTH = Math.min(50, (canvas.width - 2*50) / (numTurbines * 1.5));
  BAR_MAX_HEIGHT = canvas.height * 0.45;
  BAR_BASE_Y = canvas.height * 0.65;
  PADDING = 50;

  draw();
  updateBestScoresDisplay();
}

function toggleTurbine(i) {
  if (!gameRunning) return;
  clickCount++;
  turbines[i].clickBounce = 12;
  const pattern = turbines[i].pattern;

  for (let j=0; j<bars.length; j++) {
    if (pattern[j]) bars[j].target = !bars[j].target;
  }

  if (bars.every(b => b.target)) {
    gameRunning = false;
    showWinScreen();
  }
}

function showWinScreen() {
  const elapsed = (performance.now() - startTime)/1000;
  const stats = document.getElementById('stats');
  stats.innerHTML = `
    <p>Time: <strong>${elapsed.toFixed(2)}s</strong></p>
    <p>Clicks: <strong>${clickCount}</strong></p>
  `;
  saveBestScores(elapsed, clickCount);
  document.getElementById('winScreen').style.display = 'block';
}

function resetGame() {
  startGame(numTurbines === 10 ? 'hard' : 'easy');
}

function saveBestScores(time, clicks) {
  const best = JSON.parse(localStorage.getItem('ls-turbine-best') || '{}');
  let updated = false;
  if (!best.time || time < best.time) {
    best.time = time;
    updated = true;
  }
  if (!best.clicks || clicks < best.clicks) {
    best.clicks = clicks;
    updated = true;
  }
  if (updated) localStorage.setItem('ls-turbine-best', JSON.stringify(best));
  updateBestScoresDisplay();
}

function updateBestScoresDisplay() {
  const bestScoresDiv = document.getElementById('bestScores');
  const best = JSON.parse(localStorage.getItem('ls-turbine-best') || '{}');
  if (best.time && best.clicks) {
    bestScoresDiv.textContent = `Best Time: ${best.time.toFixed(2)}s | Least Clicks: ${best.clicks}`;
  } else {
    bestScoresDiv.textContent = 'No records yet.';
  }
}

function drawBars() {
  const space = (canvas.width - 2*PADDING - numTurbines*BAR_WIDTH) / (numTurbines-1);

  bars.forEach((bar, i) => {
    let targetHeight = bar.target ? BAR_MAX_HEIGHT : 10;
    bar.currentHeight += (targetHeight - bar.currentHeight) * 0.25;

    const x = PADDING + i*(BAR_WIDTH + space);
    const y = BAR_BASE_Y - bar.currentHeight;

    // glowing gradient fill for ON bars
    if (bar.target) {
      let grad = ctx.createLinearGradient(x, y, x, y + bar.currentHeight);
      grad.addColorStop(0, '#8cff7f');
      grad.addColorStop(1, '#0b5700');
      ctx.fillStyle = grad;
      ctx.shadowColor = '#7efc44';
      ctx.shadowBlur = 25;
    } else {
      ctx.fillStyle = '#033203';
      ctx.shadowBlur = 0;
    }

    ctx.fillRect(x, y, BAR_WIDTH, bar.currentHeight);

    // fancy border
    ctx.shadowBlur = 0;
    ctx.lineWidth = 2;
    ctx.strokeStyle = bar.target ? '#9cfc57' : '#175017';
    ctx.strokeRect(x, BAR_BASE_Y - BAR_MAX_HEIGHT, BAR_WIDTH, BAR_MAX_HEIGHT);
  });
}

function drawTurbines() {
  const space = (canvas.width - 2*PADDING - numTurbines*BAR_WIDTH) / (numTurbines-1);
  turbines.forEach((turb, i) => {
    const x = PADDING + i*(BAR_WIDTH + space) + BAR_WIDTH/2;
    const y = BAR_BASE_Y + BAR_MAX_HEIGHT * 0.2;

    turb.spinAngle += turb.spinSpeed;

    if (turb.clickBounce > 0) {
      turb.clickBounce--;
    }
    const bounceRot = Math.sin((12 - turb.clickBounce) * 0.4) * 0.7;

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(turb.spinAngle + bounceRot);

    // turbine blades - smoother gradient fill
    for (let f=0; f<4; f++) {
      let bladeGrad = ctx.createLinearGradient(0, -30, 0, 0);
      bladeGrad.addColorStop(0, f%2 === 0 ? '#a0fda0' : '#3ca63c');
      bladeGrad.addColorStop(1, '#044404');
      ctx.fillStyle = bladeGrad;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(12, -35);
      ctx.lineTo(-12, -35);
      ctx.closePath();
      ctx.fill();
      ctx.rotate(Math.PI/2);
    }
    ctx.restore();

    // label below turbine with soft glow
    ctx.fillStyle = '#9afc73';
    ctx.font = `bold ${Math.floor(BAR_WIDTH/3)}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
    ctx.textAlign = 'center';
    ctx.shadowColor = '#76ff72';
    ctx.shadowBlur = 8;
    ctx.fillText(`Turbine ${i+1}`, x, y + 55);
    ctx.shadowBlur = 0;
  });
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBars();
  drawTurbines();

  if (gameRunning) {
    requestAnimationFrame(draw);
  }
}

canvas.addEventListener('click', e => {
  if (!gameRunning) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const space = (canvas.width - 2*PADDING - numTurbines*BAR_WIDTH) / (numTurbines-1);
  for (let i=0; i<numTurbines; i++) {
    const x = PADDING + i*(BAR_WIDTH + space);
    const y = BAR_BASE_Y + BAR_MAX_HEIGHT * 0.2 - 35; // turbine center y approx

    if (mx > x && mx < x + BAR_WIDTH && my > y - 30 && my < y + 30) {
      toggleTurbine(i);
      break;
    }
  }
});

// Kick off easy mode on load
startGame('easy');
</script>

</body>
</html>
